import streamlit as st
import torch
import torch.nn as nn
import numpy as np
import pandas as pd
from torch.utils.data import DataLoader, Dataset

class MinimalTransformer(nn.Module):
    def __init__(self, vocab_size, embed_size, num_heads, forward_expansion):
        super(MinimalTransformer, self).__init__()
        self.embed = nn.Embedding(vocab_size, embed_size)
        self.positional_encoding = nn.Parameter(torch.randn(1, 100, embed_size))
        self.encoder_layer = nn.TransformerEncoderLayer(d_model=embed_size, nhead=num_heads)
        self.transformer_encoder = nn.TransformerEncoder(self.encoder_layer, num_layers=1)
        self.output_layer = nn.Linear(embed_size, vocab_size)

    def forward(self, x):
        positions = torch.arange(0, x.size(1)).unsqueeze(0)
        x = self.embed(x) + self.positional_encoding[:, :x.size(1), :]
        x = self.transformer_encoder(x)
        x = self.output_layer(x)
        return x

class NameDataset(Dataset):
    def __init__(self, csv_file):
        self.names = pd.read_csv(csv_file)['name'].values
        self.chars = sorted(list(set(''.join(self.names) + ' ')))  # Including a padding character
        self.char_to_int = {c: i for i, c in enumerate(self.chars)}
        self.int_to_char = {i: c for c, i in self.char_to_int.items()}
        self.vocab_size = len(self.chars)

    def __len__(self):
        return len(self.names)

    def __getitem__(self, idx):
          name = self.names[idx] + ' '  # Adding padding character at the end
          encoded_name = [self.char_to_int[char] for char in name]
          return torch.tensor(encoded_name)

model_path_v = "namesformer_model_v.pth"
model_path_m = "namesformer_model_m.pth"
model_v  =  torch.load(model_path_v)
model_m  =  torch.load(model_path_m)
model_v.eval()
model_m.eval()

csv_file_v = 'vardai_v.txt'
csv_file_m = 'vardai_m.txt'
dataset_v = NameDataset(csv_file_v)
dataset_m = NameDataset(csv_file_m)

def sample(model, dataset, start_str='a', max_length=20, temperature=1.0):
    assert temperature > 0, "Temperature must be greater than 0"
    model.eval()  # Switch model to evaluation mode
    with torch.no_grad():
        # Convert start string to tensor
        chars = [dataset.char_to_int[c] for c in start_str]
        input_seq = torch.tensor(chars).unsqueeze(0)  # Add batch dimension
        
        output_name = start_str
        for _ in range(max_length - len(start_str)):
            output = model(input_seq)
            
            # Apply temperature scaling
            logits = output[0, -1] / temperature
            probabilities = torch.softmax(logits, dim=0)
            
            # Sample a character from the probability distribution
            next_char_idx = torch.multinomial(probabilities, 1).item()
            next_char = dataset.int_to_char[next_char_idx]
            
            if next_char == ' ':  # Assume ' ' is your end-of-sequence character
                break
            
            # Add next character to the generated name
            output_name += next_char
            
            # Update the input sequence for the next iteration
            input_seq = torch.cat([input_seq, torch.tensor([[next_char_idx]])], dim=1)
        
        return output_name

# Streamlit UI
st.title("Next Letter Generator")
st.write("Enter a couple of letters and get the next letters generated by the model")

# Input box for user
input_text = st.text_input("Enter letters:", "")

# Slider for temperature
temperature = st.slider(
    "Select Temperature (The higher the temperature, the more creative names are generated)",
    min_value=0.2,
    max_value=1.8,
    value=1.0,
    step=0.05,
)

# Checkboxes for selecting male, female, or both
generate_male = st.checkbox("Generate Male Name", value=False)
generate_female = st.checkbox("Generate Female Name", value=False)

# Button to trigger the model
if st.button("Generate Next Letters"):
    if input_text:
        # Ensure at least one checkbox is selected
        if not generate_male and not generate_female:
            st.warning("Please select at least one: Male or Female.")
        else:
            # Generate male name if selected
            if generate_male:
                male_name = sample(model_v, dataset_v, start_str=input_text, temperature=temperature)
                st.write("Generated Male Name: ", male_name)

            # Generate female name if selected
            if generate_female:
                female_name = sample(model_m, dataset_m, start_str=input_text, temperature=temperature)
                st.write("Generated Female Name: ", female_name)
    else:
        st.warning("Please enter some text to generate the next letters.")


